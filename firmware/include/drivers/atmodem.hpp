#pragma once

#include <global.hpp>
#include <core/usart.hpp>
#include <drivers/console.hpp>

#define MODEM_IN_BUFFER_SIZE 512
#define SMS_MAX_SIZE 140

typedef struct smsctx
{
 bool read;
 char message[SMS_MAX_SIZE];
}smsctx;

namespace CMD
{
 /* Autogenerated AT command list-enumerator */
#define FOREACH_ATCMD(ATCMD) \
		ATCMD(AT)\
		ATCMD(IPR)\
		ATCMD(CNETSCAN)\
		ATCMD(CGMI)\
		ATCMD(CGMM)\
		ATCMD(CGMN)\
		ATCMD(CGMP)\
		ATCMD(CGMR)\
		ATCMD(CGMS)\
		ATCMD(CGSN)\
		ATCMD(CSCS)\
		ATCMD(CIMI)\
		ATCMD(CCLK)\
		ATCMD(CNUM)\
		ATCMD(CREG)\
		ATCMD(COPS)\
		ATCMD(CPOL)\
		ATCMD(CPLS)\
		ATCMD(CLCK)\
		ATCMD(CPWD)\
		ATCMD(CCUG)\
		ATCMD(CLCC)\
		ATCMD(CUSD)\
		ATCMD(CPAS)\
		ATCMD(CFUN)\
		ATCMD(CPIN)\
		ATCMD(CBC)\
		ATCMD(CIND)\
		ATCMD(CPBS)\
		ATCMD(CPBR)\
		ATCMD(CPBW)\
		ATCMD(CRSM)\
		ATCMD(CMAR)\
		ATCMD(CMEE)\
		ATCMD(CSMS)\
		ATCMD(CPMS)\
		ATCMD(CLIP)\
		ATCMD(CMGF)\
		ATCMD(CSCA)\
		ATCMD(CSMP)\
		ATCMD(CSDH)\
		ATCMD(CSCB)\
		ATCMD(CSAS)\
		ATCMD(CRES)\
		ATCMD(CNMI)\
		ATCMD(CMGL)\
		ATCMD(CMGR)\
		ATCMD(CMGS)\
		ATCMD(CMSS)\
		ATCMD(CMGW)\
		ATCMD(CMGD)\
		ATCMD(CENG)\
		ATCMD(CGDCONT)\
		ATCMD(CGDSCONT)\
		ATCMD(CGEQREQ)\
		ATCMD(CGQREQ )\
		ATCMD(CGQMIN )\
		ATCMD(CGEQMIN)\
		ATCMD(CGEQNEG)\
		ATCMD(CGATT)\
		ATCMD(CGACT)\
		ATCMD(CGCMOD)\
		ATCMD(CGTFT)\
		ATCMD(CGDATA)\
		ATCMD(CGPADDR)\
		ATCMD(CGCLASS)\
		ATCMD(CGREG)\
		ATCMD(CGSMS)\
		ATCMD(CPOWD)\
		ATCMD(GSMBUSY)\
		ATCMD(RFSTS)\
		ATCMD(VERSION)\
		ATCMD(BAUD)\
		ATCMD(NAME)\
		ATCMD(PIN)\
		ATCMD(WRONG_COMMAND)

#define GENERATE_ATCMD(ATCMD) ATCMD,
#define GENERATE_ATCMD_STRING(STRING) #STRING,

 typedef enum ATCMD_ENUM
 {
  FOREACH_ATCMD(GENERATE_ATCMD)
 } ATCMD;
}

namespace CMDMODE
{
 typedef enum MODE
 {
  SET,
  GET,
  CHECK,
  EXEC,
  RAW
 } MODE;
}

typedef enum OPERATOR
{
 BEELINE,
 MEGAFON,
 MTS,
 TELE2
}CELLULAR_OP;

typedef enum ATRESPONSE
{
 AT_OK,
 AT_CONNECT,
 AT_RING,
 AT_NO_CARRIER,
 AT_ERROR,
 AT_STRING,
 AT_NO_DIALTONE,
 AT_BUSY,
 AT_NO_ANSWER,
 SIM900_CALL_READY,
 SIM900_NORMAL_POWER_DOWN,
 AT_NO_REPLY,
 AT_INPUT_PROMPT,
 AT_READY
} ATRESPONSE;

class ATModem: public Uart
{
public:
 ATModem(short ch, word bd)
: Uart::Uart(ch, bd, this)
 {
  ok = false;
  go = false;
  buflen = 0;
  crlf_end = true;
  ATModem::self = this;
 }

 void rawcmd(CMD::ATCMD cmd, CMDMODE::MODE mode, const char* arg = nullptr);
 void rawcmd(CMD::ATCMD cmd, CMDMODE::MODE mode, word argument);
 bool wait_for_reply(CMD::ATCMD cmd, ATRESPONSE expected, word timeout = 1000);
 bool wait_for_reply_noend(CMD::ATCMD cmd, ATRESPONSE expected, word timeout = 1000);
 const char *get_cmd_str(CMD::ATCMD cmd);
 void use_ending(bool mode);

 static void procisr(void);
 char modembuf[MODEM_IN_BUFFER_SIZE + 1];
 short buflen;
 bool ok;
 static class ATModem *self;
protected:
 char replystr[MODEM_IN_BUFFER_SIZE + 1];
 void reset(void);
 bool crlf_end;
 bool go;
};
